from flask import Flask, request, jsonify
from flask_cors import CORS
import yt_dlp
from yt_dlp.utils import ExtractorError, DownloadError
import logging
import os
import json
import tempfile
import random

app = Flask(__name__)
CORS(app)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_video_qualities(video_url):
    # Create a temporary file for cookies
    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as temp_cookie_file:
        # Write the cookie content with the newer secure cookies
        temp_cookie_file.write("""# Netscape HTTP Cookie File
# https://curl.haxx.se/rfc/cookie_spec.html
# This file was generated by yt-dlp

.youtube.com	TRUE	/	TRUE	1781780495	__Secure-1PAPISID	WwTDrgX5pM_1uu_a/AiJuGsl94j9slHVfo
.youtube.com	TRUE	/	TRUE	1781780495	__Secure-1PSID	g.a000wwjr-jihvUHsf3_MUPbN7mT8eUjaymCbKBQb3pc92-24RCKBYAV2snCdmZFN3Nhg7hx6GAACgYKAUYSARcSFQHGX2MiD3lo6XqlxtOT13HJctIikBoVAUF8yKoPJceM4n7kEaIW-XM1UpNz0076
.youtube.com	TRUE	/	TRUE	1778837459	__Secure-1PSIDCC	AKEyXzU31m-D_QCws5DeYEFFR5SlGM2lX_CS9Fwrg-yZCBGtFaq67JmVkgxuqRtBoQYre_FbNaM
.youtube.com	TRUE	/	TRUE	1778836928	__Secure-1PSIDTS	sidts-CjIBjplskOZhdZnt5HOA5pQUfKYZ_52u1kjykgDxlUgN1rp7I84aN3yf0SetJYT43rAwbxAA
.youtube.com	TRUE	/	TRUE	1781780495	__Secure-3PAPISID	WwTDrgX5pM_1uu_a/AiJuGsl94j9slHVfo
.youtube.com	TRUE	/	TRUE	1781780495	__Secure-3PSID	g.a000wwjr-jihvUHsf3_MUPbN7mT8eUjaymCbKBQb3pc92-24RCKB0wTMjyGwOGDcwS4gL-YcCwACgYKAdsSARcSFQHGX2MilmfHhp5GJq19NBRRy9MyqRoVAUF8yKoZcSOrGzy55vN-ORbgreM-0076
.youtube.com	TRUE	/	TRUE	1778837459	__Secure-3PSIDCC	AKEyXzXQEVXNkGFKE3DnL7e4hMuhUfmcEGnUFM_8K5fRKBvo9mfxMjT7VlIx_sv_ZBXClTxC_8gg
.youtube.com	TRUE	/	TRUE	1778836928	__Secure-3PSIDTS	sidts-CjIBjplskOZhdZnt5HOA5pQUfKYZ_52u1kjykgDxlUgN1rp7I84aN3yf0SetJYT43rAwbxAA
.youtube.com	TRUE	/	TRUE	1781780495	APISID	kdQTFBYoXydAirfT/Azj2f-Ll4n1vzIfcC
.youtube.com	TRUE	/	TRUE	1781780495	HSID	AX6v6N7jhdCoZsFr0
.youtube.com	TRUE	/	TRUE	1767810687	LOGIN_INFO	AFmmF2swRQIgO3oNkT3TPMAC9iHtSKCIAJIhZjDWmwwbZCizE8cwqaUCIQCBvd7b2AGeAC5ddB4Zy9c4U--Lq3h6lTUM6m2cgdgqKw:QUQ3MjNmeFFobDNPUXVENk5wRTJReWtwdEE4eXdTUmt2UmpWMXBsNXpLNk5fTVlPYmE2QldoRjc0YXF0MUNxLVgzRkI4c1dWcnRnQUNLQmhDeHN1dG9MT3MyRm1ZNGdXRWNGWHFSalByR0RPZ3JrV3ZpWW9aVkpQZmxyWU1scXdyX243ajI3NWNFU2xDcGZBY3VOek9hVTRIU1FCRmhmaE5R
.youtube.com	TRUE	/	TRUE	1763106708	NID	524=jzyjGKhcFSF17UvrrsyEhUF94Ektrux-pbYdFTqjH2g8W9Fp66iitF7R3ms4_ep2GEs90flkAsKMZVli-A-GRRX5JkIa3nw-__3ungB0oCsjq1IB7Is_Rs_9algjwwRYQMvEntRQHw3dDjKL5WeOo9z3iZu3P-ROPYkTJ1qNWlcaBXbYcsSL-f8lZhwPMWYJZXBhh1W5x4RthGMUQ53bE8Ip_oCfJThF-Sq3QaNswvcBnQ2ZTP-lJg8U9_PtnE6uulFGsjbq0DpEq7odkSl-k_3C
.youtube.com	TRUE	/	TRUE	1781861458	PREF	tz=Asia.Calcutta&f5=30000&f7=100&f6=40000400&f4=4000000&gl=US
.youtube.com	TRUE	/	TRUE	1781780495	SAPISID	WwTDrgX5pM_1uu_a/AiJuGsl94j9slHVfo
.youtube.com	TRUE	/	TRUE	1781780495	SID	g.a000wwjr-jihvUHsf3_MUPbN7mT8eUjaymCbKBQb3pc92-24RCKBpFe8x1MEE5fA3Irm1Td8WgACgYKAfESARcSFQHGX2MiXdUOmnITlUVD2S_qMkeMpBoVAUF8yKoN-S44Ge5EV8Br4mZIqO2D0076
.youtube.com	TRUE	/	TRUE	1778837459	SIDCC	AKEyXzXR3dGfyT5Jzcp_c7oyIpzVBzV0j6XNsKui1XAeah6L-ASVRaasZtCo30_xisnQYn2Mo18
.youtube.com	TRUE	/	TRUE	1781780495	SSID	AL88MJtEUo3wIFjvB""")
        temp_cookie_path = temp_cookie_file.name

    try:
        # List of common user agents
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0'
        ]

        ydl_opts = {
            'listformats': True,
            'quiet': True,
            'no_warnings': True,
            'extract_flat': False,
            'cookies': temp_cookie_path,
            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
            'nocheckcertificate': True,
            'ignoreerrors': True,
            'no_color': True,
            'geo_bypass': True,
            'geo_verification_proxy': 'socks5://127.0.0.1:9050',  # Using Tor proxy
            'proxy': 'socks5://127.0.0.1:9050',  # Using Tor proxy
            'socket_timeout': 30,
            'retries': 10,
            'fragment_retries': 10,
            'skip_download': True,
            'http_headers': {
                'User-Agent': random.choice(user_agents),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
                'Cache-Control': 'max-age=0',
                'TE': 'trailers'
            }
        }
        
        logger.info("Using temporary cookie file with secure cookies and proxy for authentication")

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            logger.info(f"Attempting to extract info for URL: {video_url}")
            info_dict = ydl.extract_info(video_url, download=False)
            
            if not info_dict:
                logger.error("No info dictionary returned")
                return None, None, None
                
            formats = info_dict.get('formats', [])
            logger.info(f"Found {len(formats)} formats")

            video_quality_map = {}
            best_audio = None
            highest_bitrate = 0

            for f in formats:
                # Check for video formats
                if f.get('vcodec') != 'none':
                    resolution = f.get('height')
                    if resolution is not None and resolution not in video_quality_map:
                        # Get the direct URL if available, otherwise use format_id
                        url = f.get('url')
                        if not url:
                            # If no direct URL, try to get the format URL
                            try:
                                format_url = ydl.urlopen(f['url']).geturl()
                                url = format_url
                            except:
                                continue
                        video_quality_map[resolution] = url
                
                # Check for audio formats
                if f.get('acodec') != 'none' and f.get('abr') is not None:
                    bitrate = f.get('abr')
                    if bitrate > highest_bitrate:
                        url = f.get('url')
                        if url:
                            highest_bitrate = bitrate
                            best_audio = url

            video_quality_list = [{"resolution": res, "url": url} for res, url in video_quality_map.items()]
            logger.info(f"Found {len(video_quality_list)} video qualities")

            # Get the best video URL
            best_video_url = None
            if formats:
                try:
                    best_info = ydl.extract_info(video_url, download=False)
                    if isinstance(best_info, dict):
                        best_video_url = best_info.get('url')
                        if not best_video_url and 'formats' in best_info:
                            # Try to get URL from formats
                            for f in best_info['formats']:
                                if f.get('vcodec') != 'none':
                                    best_video_url = f.get('url')
                                    if best_video_url:
                                        break
                except Exception as e:
                    logger.error(f"Error getting best video URL: {str(e)}")
                    best_video_url = None

            return video_quality_list, best_audio, best_video_url

    except Exception as e:
        logger.error(f"Error in get_video_qualities: {str(e)}")
        return None, None, None
    finally:
        # Clean up the temporary cookie file
        try:
            os.unlink(temp_cookie_path)
        except:
            pass


def get_video_url_by_quality(video_list, selected_quality):
    if not video_list:
        return None

    selected_resolution = selected_quality.rstrip('p')  # Remove 'p' from resolution if present
    for video in video_list:
        resolution = str(video['resolution']).rstrip('p') if video['resolution'] else None
        if resolution == selected_resolution:
            return video['url']
    return None


@app.route('/get_video_url', methods=['GET'])
def get_video_url():
    video_id = request.args.get('video_id')
    quality = request.args.get('quality')
    
    if not video_id:
        return jsonify({"error": "Video ID must be provided"}), 400

    video_url = f'https://www.youtube.com/watch?v={video_id}'
    logger.info(f"Processing request for video ID: {video_id}")
    
    try:
        video_qualities, best_audio_url, best_video_url = get_video_qualities(video_url)

        if video_qualities is None and best_audio_url is None and best_video_url is None:
            logger.error(f"Failed to extract video information for ID: {video_id}")
            return jsonify({
                "error": "Video is unavailable or restricted",
                "video_id": video_id,
                "message": "Could not extract video information. The video might be private, restricted, or unavailable in your region."
            }), 404

        response_data = {
            "best_audio_url": best_audio_url,
            "best_video_url": best_video_url,
            "video_quality_options": video_qualities
        }

        if quality:
            selected_video_url = get_video_url_by_quality(video_qualities, quality)
            if selected_video_url:
                response_data["selected_video_url"] = selected_video_url
            else:
                logger.warning(f"Requested quality {quality} not found for video ID: {video_id}")
                return jsonify({
                    "error": f"No URL found for quality {quality}",
                    "video_id": video_id,
                    "available_qualities": [q["resolution"] for q in video_qualities]
                }), 404

        return jsonify(response_data)

    except Exception as e:
        logger.error(f"Unexpected error processing video ID {video_id}: {str(e)}")
        return jsonify({
            "error": "An unexpected error occurred",
            "video_id": video_id,
            "message": str(e)
        }), 500

        
@app.route('/keep-alive', methods=['GET'])
def keep_alive():
    return jsonify({"success": True})


@app.route('/get-short-url', methods=['GET'])
def get_short_url():
    video_id = request.args.get('video_id')
    if not video_id:
        return jsonify({"error": "Video ID must be provided"}), 400

    video_url = f'https://www.youtube.com/watch?v={video_id}'
    _, _, best_video_url = get_video_qualities(video_url)

    if best_video_url is None:
        return jsonify({"error": "Video is unavailable or restricted"}), 404

    return jsonify({"stream_url": best_video_url})


if __name__ == "__main__":
    app.run(host='0.0.0.0', port=8111)
